<!-- <!DOCTYPE html>
<html>
<head>
  <title>Team Audio Chat (WebRTC)</title>
  <style>
    body { font-family: Arial; text-align: center; padding: 20px; }
    #status { font-weight: bold; margin-bottom: 10px; color: green; }
    audio { margin-top: 20px; width: 100%; }
    #playBtn { margin-top: 20px; padding: 10px 20px; font-size: 16px; cursor: pointer; }
  </style>
</head>
<body>
  <h2>üé§ Team Audio Chat</h2>
  <div id="status">Connecting...</div>
  <audio id="remoteAudio" controls></audio>
  <br />
  <button id="playBtn" style="display:none;">Start Audio</button>

  <script>
    const myId = `user-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    const socket = new WebSocket("ws://192.168.1.20:8022/ws"); // Update IP if needed
    const statusDiv = document.getElementById("status");
    const remoteAudio = document.getElementById("remoteAudio");
    const playBtn = document.getElementById("playBtn");

    const peerConnection = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    let localStream;

    async function initMedia() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        console.log("Local audio tracks:", localStream.getAudioTracks());
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        statusDiv.textContent = "üéôÔ∏è Microphone access granted.";
      } catch (err) {
        console.error("Mic access failed", err);
        statusDiv.textContent = "‚ùå Cannot access microphone.";
        statusDiv.style.color = "red";
      }
    }

    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        socket.send(JSON.stringify({
          type: "ice",
          candidate: event.candidate,
          userId: myId,
        }));
      }
    };

    peerConnection.ontrack = (event) => {
      const stream = event.streams[0];
      console.log("Received remote stream:", stream);
      console.log("Audio tracks on remote stream:", stream.getAudioTracks());

      if (stream) {
        remoteAudio.srcObject = stream;
        remoteAudio.volume = 1;
        remoteAudio.muted = false;
        statusDiv.textContent = "üîÑ Remote stream received. Click 'Start Audio' to play.";
        playBtn.style.display = 'inline-block'; // Show play button
      }
    };

    playBtn.onclick = () => {
      remoteAudio.play()
        .then(() => {
          playBtn.style.display = 'none';
          statusDiv.textContent = "üîä Audio playing";
        })
        .catch(e => {
          console.warn("Audio play failed:", e);
          statusDiv.textContent = "‚ùå Audio play failed ‚Äî user interaction required.";
          statusDiv.style.color = "red";
        });
    };

    socket.onopen = async () => {
      statusDiv.textContent = `‚úÖ Connected as ${myId}`;
      socket.send(JSON.stringify({ userId: myId })); // Send userId to register

      await initMedia();

      setTimeout(async () => {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.send(JSON.stringify({
          type: "offer",
          offer: offer,
          userId: myId
        }));
      }, 1000);
    };

    socket.onmessage = async (event) => {
      const msg = JSON.parse(event.data);
      if (msg.userId === myId) return;

      switch (msg.type) {
        case "offer":
          await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.send(JSON.stringify({ type: "answer", answer: answer, userId: myId }));
          break;

        case "answer":
          await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.answer));
          break;

        case "ice":
          if (msg.candidate) {
            try {
              await peerConnection.addIceCandidate(new RTCIceCandidate(msg.candidate));
            } catch (err) {
              console.error("Error adding ICE candidate", err);
            }
          }
          break;
      }
    };

    socket.onerror = (err) => {
      console.error("WebSocket error", err);
      statusDiv.textContent = "‚ùå WebSocket error";
      statusDiv.style.color = "red";
    };

    socket.onclose = () => {
      statusDiv.textContent = "‚ùå WebSocket disconnected";
      statusDiv.style.color = "red";
    };
  </script>
</body>
</html> -->


<!DOCTYPE html>
<html>
<head>
  <title>Mesh WebRTC Video Chat</title>
  <link rel="icon" href="data:,">
  <style>
    body { margin: 0; font-family: sans-serif; background: #111; color: white; }
    .videos { display: flex; flex-wrap: wrap; justify-content: center; }
    video { width: 300px; margin: 10px; background: black; border: 2px solid #333; }
    .videoLabel { text-align: center; margin-top: -5px; font-size: 14px; }
  </style>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
</head>
<body>
  <div id="videos" class="videos">
    <div id="localVideoContainer">
      <video id="localVideo" autoplay muted></video>
    </div>
  </div>
  <script>
    const WS_PORT = 8443;
    let localUuid = createUUID();
    let localDisplayName = prompt("Enter your name:");
    let localStream;
    let serverConnection;
    let peerConnections = {};
    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    function createUUID() {
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }

    function start() {
      navigator.mediaDevices.getUserMedia({ video: true, audio: false }).then(stream => {
        localStream = stream;
        document.getElementById('localVideo').srcObject = stream;
        connectSocket();
      });
    }

    function connectSocket() {
      serverConnection = new WebSocket('wss://' + window.location.hostname + ':' + WS_PORT + '/ws');
      serverConnection.onopen = () => {
        serverConnection.send(JSON.stringify({ uuid: localUuid, displayName: localDisplayName, dest: 'all' }));
      };

      serverConnection.onmessage = msg => {
        let signal = JSON.parse(msg.data);
        if (signal.uuid === localUuid || (signal.dest !== 'all' && signal.dest !== localUuid)) return;

        if (signal.displayName && signal.dest === 'all') {
          setUpPeer(signal.uuid, signal.displayName);
          serverConnection.send(JSON.stringify({ uuid: localUuid, displayName: localDisplayName, dest: signal.uuid }));
        } else if (signal.displayName && signal.dest === localUuid) {
          setUpPeer(signal.uuid, signal.displayName, true);
        } else if (signal.sdp) {
          peerConnections[signal.uuid].pc.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(() => {
            if (signal.sdp.type === 'offer') {
              peerConnections[signal.uuid].pc.createAnswer().then(desc => setLocalDesc(desc, signal.uuid));
            }
          });
        } else if (signal.ice) {
          peerConnections[signal.uuid].pc.addIceCandidate(new RTCIceCandidate(signal.ice));
        }
      };
    }

    function setUpPeer(uuid, name, initiate = false) {
      let pc = new RTCPeerConnection(config);
      peerConnections[uuid] = { pc: pc, name: name };

      pc.onicecandidate = e => {
        if (e.candidate) {
          serverConnection.send(JSON.stringify({ ice: e.candidate, uuid: localUuid, dest: uuid }));
        }
      };

      pc.ontrack = e => {
        let video = document.createElement('video');
        video.autoplay = true;
        video.srcObject = e.streams[0];
        let label = document.createElement('div');
        label.className = 'videoLabel';
        label.textContent = name;
        let container = document.createElement('div');
        container.appendChild(video);
        container.appendChild(label);
        container.id = "remote_" + uuid;
        document.getElementById('videos').appendChild(container);
      };

      pc.oniceconnectionstatechange = () => {
        if (['disconnected', 'failed', 'closed'].includes(pc.iceConnectionState)) {
          document.getElementById('remote_' + uuid)?.remove();
          delete peerConnections[uuid];
        }
      };

      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      if (initiate) {
        pc.createOffer().then(desc => setLocalDesc(desc, uuid));
      }
    }

    function setLocalDesc(desc, uuid) {
      peerConnections[uuid].pc.setLocalDescription(desc).then(() => {
        serverConnection.send(JSON.stringify({ sdp: desc, uuid: localUuid, dest: uuid }));
      });
    }

    start();
  </script>
</body>
</html>

