<!-- <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Audio Only SFU</title>
</head>

<body>
  <h2>My Microphone</h2>
  <p>You're sharing your mic with others in the room.</p>

  <button id="toggleMic">Mute Mic</button>
  <p id="micStatus">Mic is <strong>ON</strong></p>

  <h3>Remote Volume</h3>
  <input type="range" id="volumeSlider" min="0" max="2" step="0.01" value="1" />
  <span id="volumeLabel">1.00</span>

  <audio id="localAudioId" controls autoplay muted></audio>
  <div class="border">
    <div id="remoteAudioDivId"></div>
  </div>

  <h3>Logs</h3>
  <div id="logs"></div>

  <script>
    let localStream;
    let micEnabled = true;

    const micStatusLabel = document.getElementById('micStatus');
    const toggleMicBtn = document.getElementById('toggleMic');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeLabel = document.getElementById('volumeLabel');

    // Web Audio API setup
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const globalGainNode = audioContext.createGain();
    globalGainNode.gain.value = parseFloat(volumeSlider.value);
    globalGainNode.connect(audioContext.destination);

    toggleMicBtn.onclick = () => {
      if (!localStream) return;

      micEnabled = !micEnabled;
      localStream.getAudioTracks()[0].enabled = micEnabled;

      micStatusLabel.innerHTML = `Mic is <strong>${micEnabled ? 'ON' : 'OFF'}</strong>`;
      toggleMicBtn.textContent = micEnabled ? 'Mute Mic' : 'Unmute Mic';
    };

    volumeSlider.oninput = () => {
      const volume = parseFloat(volumeSlider.value);
      globalGainNode.gain.value = volume;
      volumeLabel.textContent = volume.toFixed(2);
    };

    navigator.mediaDevices.getUserMedia({ audio: true, video: false })
      .then(stream => {
        localStream = stream;
        document.getElementById('localAudioId').srcObject = stream
        log('Microphone access granted.');

        const pc = new RTCPeerConnection();
        stream.getTracks().forEach(track => pc.addTrack(track, stream));

        pc.ontrack = event => {
          log('Received remote audio track');

          let el = document.createElement(event.track.kind)
          el.srcObject = event.streams[0]
          el.autoplay = true
          el.controls = true
          document.getElementById('remoteAudioDivId').appendChild(el)

          event.track.onmute = function (event) {
            el.play()
          }

          event.streams[0].onremovetrack = ({ track }) => {
            if (el.parentNode) {
              el.parentNode.removeChild(el)
            }
          }

          const remoteStream = event.streams[0];
          const audioSource = audioContext.createMediaStreamSource(remoteStream);
          audioSource.connect(globalGainNode); // Route through global gain node
        };

        const ws = new WebSocket("{{.WebSocketURL}}");

        ws.onopen = () => log('WebSocket connected.');
        ws.onmessage = evt => {
          const msg = JSON.parse(evt.data);
          if (!msg) return;

          switch (msg.event) {
            case 'offer':
              const offer = JSON.parse(msg.data);
              pc.setRemoteDescription(offer).then(() => pc.createAnswer()).then(answer => {
                pc.setLocalDescription(answer);
                ws.send(JSON.stringify({ event: 'answer', data: JSON.stringify(answer) }));
              });
              break;
            case 'candidate':
              const candidate = JSON.parse(msg.data);
              pc.addIceCandidate(candidate);
              break;
          }
        };

        ws.onclose = () => log('WebSocket closed.');
        ws.onerror = err => log('WebSocket error: ' + err.message);

        pc.onicecandidate = e => {
          if (e.candidate) {
            ws.send(JSON.stringify({
              event: 'candidate',
              data: JSON.stringify(e.candidate)
            }));
          }
        };
      })
      .catch(err => {
        alert('Could not access microphone: ' + err.message);
      });

    function log(msg) {
      console.log(msg);
      const logDiv = document.getElementById('logs');
      const entry = document.createElement('div');
      entry.textContent = msg;
      logDiv.appendChild(entry);
    }
  </script>
</body>

</html> -->


<!-- <main>
      <h2 class="text-center">WebRTC Audio Only Demo</h2>

      <section>
        <h3>Local Audio</h3>
        <audio id="localAudio" autoplay muted controls></audio>
      </section>

      <section>
        <h3>Remote Audio</h3>
        <div id="remoteAudios"></div>
      </section>

      <section>
        <h3>Logs</h3>
        <div id="logs"></div>
      </section>
    </main> -->

    <!-- <script>
      const log = (msg) => {
        console.log(msg);
        const div = document.getElementById("logs");
        div.innerHTML += msg + "<br>";
      };

      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          // Local audio preview
          document.getElementById("localAudio").srcObject = stream;

          const pc = new RTCPeerConnection();

          // Add local audio tracks
          stream.getTracks().forEach(track => pc.addTrack(track, stream));

          // Handle remote audio tracks
          pc.ontrack = (event) => {
            if (event.track.kind !== "audio") return;

            const el = document.createElement("audio");
            el.srcObject = event.streams[0];
            el.autoplay = true;
            el.controls = true;
            document.getElementById("remoteAudios").appendChild(el);

            event.streams[0].onremovetrack = ({ track }) => {
              if (el.parentNode) el.parentNode.removeChild(el);
            };
          };

          // Create WebSocket connection (Go template variable inserted here)
          const ws = new WebSocket("{{.WebSocketURL}}");

          pc.onicecandidate = (e) => {
            if (!e.candidate) return;
            ws.send(JSON.stringify({
              event: "candidate",
              data: JSON.stringify(e.candidate)
            }));
          };

          ws.onclose = () => {
            alert("WebSocket connection closed");
          };

          ws.onerror = (evt) => {
            log("WebSocket ERROR: " + evt.data);
          };

          ws.onmessage = (evt) => {
            let msg;
            try {
              msg = JSON.parse(evt.data);
            } catch (err) {
              return log("Failed to parse message: " + evt.data);
            }

            switch (msg.event) {
              case "offer":
                const offer = JSON.parse(msg.data);
                pc.setRemoteDescription(offer)
                  .then(() => pc.createAnswer())
                  .then(answer => {
                    pc.setLocalDescription(answer);
                    ws.send(JSON.stringify({
                      event: "answer",
                      data: JSON.stringify(answer)
                    }));
                  });
                break;

              case "candidate":
                const candidate = JSON.parse(msg.data);
                pc.addIceCandidate(candidate);
                break;

              default:
                log("Unknown event: " + msg.event);
            }
          };
        })
        .catch(err => {
          alert("getUserMedia error: " + err);
          log("getUserMedia error: " + err);
        });
    </script> -->


    <main>
      <h2>WebRTC Audio Only Demo</h2>

      <section>
        <h3>Local Audio</h3>
        <audio id="localAudio" autoplay muted controls></audio>
      </section>

      <section>
        <h3>Remote Audio</h3>
        <div id="remoteAudios"></div>
      </section>

      <section>
        <h3>Logs</h3>
        <div id="logs"></div>
      </section>
    </main>

    <!-- <script>
      const log = (msg) => {
        console.log(msg);
        const div = document.getElementById("logs");
        div.innerHTML += msg + "<br>";
        div.scrollTop = div.scrollHeight;
      };

      // ðŸ”¹ Extract username from WebSocket URL
      const wsURL = "{{.WebSocketURL}}";
      const urlParams = new URLSearchParams(wsURL.split('?')[1]);
      const currentUsername = urlParams.get('username') || "Unknown";
      log("Your username: " + currentUsername);

      const remoteUsers = {};          // track.id -> {element, label}
      const pendingNames = new Set();  // usernames waiting for a track

      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          document.getElementById("localAudio").srcObject = stream;

          const pc = new RTCPeerConnection();

          // Add local audio
          stream.getTracks().forEach(track => pc.addTrack(track, stream));

          // When remote tracks arrive
          pc.ontrack = (event) => {
            if (event.track.kind !== "audio") return;
            const el = document.createElement("audio");
            el.srcObject = event.streams[0];
            el.autoplay = true;
            el.controls = true;

            const container = document.createElement("div");
            container.className = "remote-audio-item";

            const nameLabel = document.createElement("p");
            nameLabel.textContent = "ðŸŽ¤ Unknown user";
            nameLabel.style.fontWeight = "bold";

            container.appendChild(nameLabel);
            container.appendChild(el);
            document.getElementById("remoteAudios").appendChild(container);

            remoteUsers[event.track.id] = { element: container, nameLabel };
            log(`ðŸŽ§ New remote track added (id: ${event.track.id})`);

            // If we have pending names, assign them now
            if (pendingNames.size > 0) {
              const nextName = pendingNames.values().next().value;
              pendingNames.delete(nextName);
              nameLabel.textContent = `ðŸŽ¤ ${nextName}`;
              log(`âœ… Assigned queued name ${nextName} to new track`);
            }

            event.streams[0].onremovetrack = ({ track }) => {
              if (container.parentNode) container.parentNode.removeChild(container);
              delete remoteUsers[track.id];
            };
          };

          // Connect WebSocket
          const ws = new WebSocket(wsURL);

          ws.onopen = () => log("WebSocket connected âœ…");
          ws.onclose = () => log("WebSocket disconnected âŒ");
          ws.onerror = (evt) => log("WebSocket error: " + evt.data);

          // ICE candidate handler
          pc.onicecandidate = (e) => {
            if (e.candidate && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                event: "candidate",
                data: JSON.stringify(e.candidate)
              }));
            }
          };

          ws.onmessage = (evt) => {
            let msg;
            try {
              msg = JSON.parse(evt.data);
            } catch (err) {
              return log("Failed to parse message: " + evt.data);
            }

            switch (msg.event) {
              case "offer": {
                const offer = JSON.parse(msg.data);
                const username = msg.user || "Unknown";
                log(`ðŸ“¨ Received offer from ${username}`);
                console.log("currentUsername", currentUsername, "username", username);

                if (username === currentUsername) {
                  log("â†©ï¸ Offer is from yourself â€” skipping label update");
                } else {
                  // Label remote audio or queue username if no track yet
                  let labeled = false;
                  for (const trackId in remoteUsers) {
                    const user = remoteUsers[trackId];
                    if (user.nameLabel.textContent === "ðŸŽ¤ Unknown user") {
                      user.nameLabel.textContent = `ðŸŽ¤ ${username}`;
                      labeled = true;
                      log(`âœ… Labeled remote track as ${username}`);
                      break;
                    }
                  }

                  if (!labeled) {
                    pendingNames.add(username);
                    log(`ðŸ•“ No available track for ${username}, queued name`);
                  }
                }

                pc.setRemoteDescription(offer)
                  .then(() => pc.createAnswer())
                  .then(answer => {
                    pc.setLocalDescription(answer);
                    if (ws.readyState === WebSocket.OPEN) {
                      ws.send(JSON.stringify({
                        event: "answer",
                        data: JSON.stringify(answer)
                      }));
                    }
                    log(`âœ… Sent answer to ${username}`);
                  })
                  .catch(err => log("Error handling offer: " + err));
                break;
              }

              case "candidate": {
                const candidate = JSON.parse(msg.data);
                pc.addIceCandidate(candidate).catch(err => log("ICE add error: " + err));
                break;
              }

              default:
                log("Unknown event: " + msg.event);
            }
          };
        })
        .catch(err => {
          alert("Microphone error: " + err);
          log("Microphone error: " + err);
        });
    </script> -->



    <script>
  const log = (msg) => {
    console.log(msg);
    const div = document.getElementById("logs");
    div.innerHTML += msg + "<br>";
    div.scrollTop = div.scrollHeight;
  };

  const wsURL = "{{.WebSocketURL}}";
  const urlParams = new URLSearchParams(wsURL.split('?')[1]);
  const currentUsername = urlParams.get('username') || "Unknown";
  log("Your username: " + currentUsername);

  // track.id -> { element, nameLabel, username }
  const remoteUsers = {};
  const pendingNames = new Set();

  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(stream => {
      document.getElementById("localAudio").srcObject = stream;
      const pc = new RTCPeerConnection();

      // Add local audio tracks
      stream.getTracks().forEach(track => pc.addTrack(track, stream));

      // Handle incoming remote tracks
      pc.ontrack = (event) => {
        if (event.track.kind !== "audio") return;

        const el = document.createElement("audio");
        el.srcObject = event.streams[0];
        el.autoplay = true;
        el.controls = true;

        const container = document.createElement("div");
        container.className = "remote-audio-item";

        const nameLabel = document.createElement("p");
        nameLabel.textContent = "ðŸŽ¤ Unknown user";
        nameLabel.style.fontWeight = "bold";

        container.appendChild(nameLabel);
        container.appendChild(el);
        document.getElementById("remoteAudios").appendChild(container);

        remoteUsers[event.track.id] = { element: container, nameLabel, username: null };
        log(`ðŸŽ§ New remote track added (id: ${event.track.id})`);

        // Assign pending name if exists
        if (pendingNames.size > 0) {
          const nextName = pendingNames.values().next().value;
          pendingNames.delete(nextName);
          nameLabel.textContent = `ðŸŽ¤ ${nextName}`;
          remoteUsers[event.track.id].username = nextName;
          log(`âœ… Assigned queued name ${nextName} to new track`);
        }
      };

      const ws = new WebSocket(wsURL);

      ws.onopen = () => log("WebSocket connected âœ…");
      ws.onclose = () => log("WebSocket disconnected âŒ");
      ws.onerror = (evt) => log("WebSocket error: " + evt.data);

      pc.onicecandidate = (e) => {
        if (e.candidate && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            event: "candidate",
            data: JSON.stringify(e.candidate)
          }));
        }
      };

      ws.onmessage = (evt) => {
        let msg;
        try { msg = JSON.parse(evt.data); } 
        catch (err) { return log("Failed to parse message: " + evt.data); }

        switch (msg.event) {

          case "offer": {
            const offer = JSON.parse(msg.data);
            const username = msg.user || "Unknown";
            log(`ðŸ“¨ Received offer from ${username}`);

            if (username === currentUsername) {
              log("â†©ï¸ Offer is from yourself â€” skipping label update");
            } else {
              // Label remote audio OR queue username
              let labeled = false;
              for (const trackId in remoteUsers) {
                const track = remoteUsers[trackId];
                if (track.nameLabel.textContent === "ðŸŽ¤ Unknown user") {
                  track.nameLabel.textContent = `ðŸŽ¤ ${username}`;
                  track.username = username;
                  labeled = true;
                  log(`âœ… Labeled remote track as ${username}`);
                  break;
                }
              }
              if (!labeled) {
                pendingNames.add(username);
                log(`ðŸ•“ No available track for ${username}, queued name`);
              }
            }

            pc.setRemoteDescription(offer)
              .then(() => pc.createAnswer())
              .then(answer => {
                pc.setLocalDescription(answer);
                if (ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({ event: "answer", data: JSON.stringify(answer) }));
                }
                log(`âœ… Sent answer to ${username}`);
              })
              .catch(err => log("Error handling offer: " + err));
            break;
          }

          case "candidate": {
            const candidate = JSON.parse(msg.data);
            pc.addIceCandidate(candidate).catch(err => log("ICE add error: " + err));
            break;
          }

          // ðŸ”¹ REMOVE TRACK BY USERNAME
          case "removeTrack": {
            const removeUser = msg.user;
            log(`ðŸ—‘ Remove request for username: ${removeUser}`);

            let found = false;
            for (const id in remoteUsers) {
              const entry = remoteUsers[id];
              if (entry.username === removeUser) {
                found = true;

                // Stop all audio tracks
                const audioEl = entry.element.querySelector("audio");
                if (audioEl?.srcObject) {
                  audioEl.srcObject.getTracks().forEach(track => track.stop());
                }

                // Remove DOM
                entry.element.remove();

                // Remove from map
                delete remoteUsers[id];
                log(`âœ… Cleaned up remote track for ${removeUser}`);
              }
            }

            if (!found) log(`âš  No UI found for ${removeUser}`);
            break;
          }

          default:
            log("Unknown event: " + msg.event);
        }
      };

    })
    .catch(err => {
      alert("Microphone error: " + err);
      log("Microphone error: " + err);
    });
</script>
